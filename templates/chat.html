<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SmartAssist Chat | TAMUCC Campus Assistant</title>

  <!-- Poppins Font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet CSS for Maps -->
  <!-- <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
        crossorigin=""/> -->

  <!-- Leaflet Routing Machine CSS -->
  <!-- <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" /> -->

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            tamuccBlue: '#0067A5',
            tamuccTeal: '#00A99D',
            tamuccLight: '#00AEEF',
            tamuccGray: '#f5f7fa',
          },
          fontFamily: {
            sans: ['Poppins', 'sans-serif'],
          }
        }
      }
    }
  </script>

  <style>
    * {
      font-family: 'Poppins', sans-serif;
    }
  </style>
</head>

<body class="bg-tamuccGray min-h-screen flex flex-col">

  <!-- Header -->
  <header class="bg-white border-b border-gray-200 shadow-sm sticky top-0 z-50">
    <div class="max-w-7xl mx-auto flex justify-between items-center px-6 py-4">
      <div class="flex items-center space-x-3">
        <img src="{{ url_for('static', path='assets/images/logo.png') }}" alt="SmartAssist Logo"
          class="h-10 w-10 object-contain rounded-lg shadow-sm">
        <div>
          <h1 class="text-xl font-semibold text-gray-800">SmartAssist</h1>
          <p class="text-xs text-gray-500">TAMUCC Campus Assistant</p>
        </div>
      </div>

      <div class="flex items-center space-x-4">
        <button id="end-live-chat"
          class="hidden text-sm bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition font-medium">
          End Live Chat
        </button>

        <button id="clear-chat"
          class="text-sm bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200 transition font-medium">
          Clear Chat
        </button>

        <a id="back-home-link" href="/guest_home"
          class="text-sm text-tamuccBlue hover:text-tamuccTeal transition font-medium">
          ‚Üê Back to Home
        </a>
      </div>
    </div>
  </header>

  <!-- Chat Container -->
  <!-- Chat Container -->
  <main class="flex-grow flex justify-center px-4 py-6 max-w-7xl mx-auto w-full">
    <div
      class="w-full max-w-5xl bg-white rounded-xl shadow-lg border border-gray-200 flex flex-col h-[calc(100vh-160px)] overflow-hidden">

      <!-- Chat Header -->
      <div
        class="bg-gradient-to-r from-tamuccBlue to-tamuccTeal text-white px-6 py-4 flex justify-between items-center rounded-t-xl">
        <div class="flex items-center space-x-3">
          <div class="h-3 w-3 bg-green-400 rounded-full animate-pulse shadow-lg"></div>
          <h2 class="font-semibold text-lg">SmartAssist Virtual Assistant</h2>
        </div>
        <span id="live-status" class="hidden text-xs bg-white/20 px-3 py-1.5 rounded-full font-medium">üü¢ Live Chat
          Active</span>
      </div>

      <div class="px-6 py-3 bg-white border-b border-gray-200 flex flex-wrap items-center justify-between gap-3">
        <div class="text-xs text-gray-500">
          <span class="font-semibold text-gray-700">Focus:</span>
          <span id="mode-description" class="font-semibold text-tamuccBlue">University services &amp; campus
            support</span>
        </div>
        <div id="mode-toggle" class="flex items-center bg-gray-100 rounded-full p-1 shadow-inner text-xs font-medium">
          <button data-mode="uni" type="button"
            class="mode-btn px-3 py-1.5 rounded-full bg-white text-tamuccBlue shadow" aria-pressed="true">
            üéì Uni Mode
          </button>
          <button data-mode="learning" type="button"
            class="mode-btn px-3 py-1.5 rounded-full text-gray-500 hover:text-tamuccBlue transition"
            aria-pressed="false">
            üìö My Learning
          </button>
        </div>
      </div>

      <!-- Queue Timer (appears only after escalate) -->
      <div id="queue-timer"
        class="hidden text-sm text-amber-700 bg-amber-50 border-b border-amber-200 px-6 py-3 font-medium">
        ‚è≥ Connecting you to an admin‚Ä¶
      </div>

      <!-- Single Chat Window -->
      <div id="chat-window" class="flex-1 overflow-y-auto p-6 space-y-4 bg-gray-50">
        <div class="flex items-start space-x-3">
          <div
            class="w-10 h-10 bg-gradient-to-br from-tamuccBlue to-tamuccTeal rounded-full flex items-center justify-center text-white font-bold shadow-md flex-shrink-0">
            S</div>
          <div
            class="bg-white px-5 py-3 rounded-2xl rounded-tl-sm shadow-sm text-gray-800 max-w-[75%] border border-gray-100">
            <p>üëã Hi! I'm <strong class="text-tamuccBlue">SmartAssist</strong>. How can I help you today?</p>
          </div>
        </div>
      </div>

      <!-- Typing Indicator -->
      <div id="typing" class="hidden px-6 py-3 bg-gray-50 border-t border-gray-200">
        <div class="flex space-x-2 items-center text-gray-500">
          <span class="dot bg-tamuccTeal w-2 h-2 rounded-full animate-bounce"></span>
          <span class="dot bg-tamuccTeal w-2 h-2 rounded-full animate-bounce [animation-delay:0.2s]"></span>
          <span class="dot bg-tamuccTeal w-2 h-2 rounded-full animate-bounce [animation-delay:0.4s]"></span>
          <p class="text-sm ml-2 font-medium">SmartAssist is typing...</p>
        </div>
      </div>

      <!-- Single Input Area (used by both bot & live chat) -->
      <div class="border-t border-gray-200 bg-white p-5 flex items-center space-x-3 rounded-b-xl">
        <input id="chat-input" type="text" placeholder="Ask me anything about campus services..."
          class="flex-grow bg-gray-50 rounded-xl px-5 py-3.5 text-sm focus:outline-none focus:ring-2 focus:ring-tamuccTeal border border-gray-200 transition">
        <button id="send-btn"
          class="bg-gradient-to-r from-tamuccBlue to-tamuccTeal text-white px-6 py-3.5 rounded-xl hover:shadow-lg transition font-semibold flex items-center justify-center min-w-[56px]">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
            class="w-5 h-5">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
          </svg>
        </button>
      </div>
    </div>
  </main>
  <div id="map-modal"
    class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-40 flex items-center justify-center p-4">
    <div class="bg-white w-full max-w-2xl h-[70vh] rounded-lg shadow-2xl flex flex-col">
      <div class="p-4 border-b flex justify-between items-center">
        <h3 class="text-lg font-semibold">Campus Walking Directions</h3>
        <button id="map-close-btn" class="text-2xl font-bold text-gray-500 hover:text-black">√ó</button>
      </div>
      <div id="map-canvas" class="flex-1 w-full h-full">
        <div class="w-full h-full flex items-center justify-center text-gray-500">Loading map...</div>
      </div>
    </div>
  </div>

  <!-- MD libs BEFORE the inline script -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCDNbOuuoHn9zJHrl7aJxiWYV7k_sOrhF0&callback=initMap"
    async defer>
    </script>
  <!-- Leaflet JS for Maps -->
  <!-- <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
          crossorigin=""></script> -->

  <!-- Leaflet Routing Machine JS -->
  <!-- <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script> -->

  <script>
    const chatWindow = document.getElementById('chat-window');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const clearChat = document.getElementById('clear-chat');
    const typingIndicator = document.getElementById('typing');
    const endLiveBtn = document.getElementById('end-live-chat');
    const liveStatus = document.getElementById('live-status');
    const queueTimerEl = document.getElementById('queue-timer');
    const backHomeLink = document.getElementById('back-home-link');
    const modeToggle = document.getElementById('mode-toggle');
    const modeDescription = document.getElementById('mode-description');
    // ‚ú® Map modal elements (now they will be found correctly)
    const mapModal = document.getElementById('map-modal');
    const mapCanvas = document.getElementById('map-canvas');
    const mapCloseBtn = document.getElementById('map-close-btn');

    const MODE_META = {
      uni: {
        description: 'University services & campus support',
        placeholder: 'Ask me anything about campus services, events, or student resources...',
        switchMessage: 'Switched to Uni Mode. Ask about campus services, offices, and student support.'
      },
      learning: {
        description: 'My Learning ‚Äî courses, CRNs, and academic help',
        placeholder: 'Ask about your courses, credit hours, CRNs, or academic requirements...',
        switchMessage: 'Switched to My Learning Mode. Ask about courses, schedules, and registration details.'
      }
    };

    let chatMode = (localStorage.getItem('smartassist_chat_mode') || 'uni').toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(MODE_META, chatMode)) {
      chatMode = 'uni';
    }

    function setChatMode(mode, { announce = false } = {}) {
      if (!Object.prototype.hasOwnProperty.call(MODE_META, mode)) {
        mode = 'uni';
      }

      chatMode = mode;
      localStorage.setItem('smartassist_chat_mode', chatMode);

      const meta = MODE_META[chatMode];
      if (modeDescription) {
        modeDescription.textContent = meta.description;
      }
      if (chatInput) {
        chatInput.placeholder = meta.placeholder;
      }
      if (modeToggle) {
        modeToggle.querySelectorAll('button').forEach(btn => {
          const isActive = btn.dataset.mode === chatMode;
          btn.classList.toggle('bg-white', isActive);
          btn.classList.toggle('text-tamuccBlue', isActive);
          btn.classList.toggle('shadow', isActive);
          btn.classList.toggle('text-gray-500', !isActive);
          btn.classList.toggle('hover:text-tamuccBlue', !isActive);
          btn.classList.toggle('opacity-80', !isActive);
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      if (announce) {
        appendMessage('system', meta.switchMessage);
      }
    }

    if (modeToggle) {
      modeToggle.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
          const mode = (btn.dataset.mode || '').toLowerCase();
          if (mode && mode !== chatMode) {
            setChatMode(mode, { announce: true });
          }
        });
      });
    }

    setChatMode(chatMode, { announce: false });

    // ---------- Set Back to Home link based on user role ----------
    async function setBackHomeLink() {
      try {
        const response = await fetch('/api/user');
        if (response.ok) {
          const user = await response.json();
          // User is logged in - redirect based on role
          if (user.role === 'student') {
            backHomeLink.href = '/student_home';
          } else if (user.role === 'admin') {
            backHomeLink.href = '/admin_home';
          } else if (user.role === 'staff') {
            backHomeLink.href = '/staff_home';
          } else {
            backHomeLink.href = '/guest_home';
          }
        } else {
          // User not logged in - go to guest home
          backHomeLink.href = '/guest_home';
        }
      } catch (error) {
        // Error or not logged in - default to guest home
        backHomeLink.href = '/guest_home';
      }
    }

    // Call on page load
    setBackHomeLink();

    // ---------- Persistent Session ----------
    let sessionId = localStorage.getItem('student_session_id');
    if (!sessionId) {
      sessionId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now());
      localStorage.setItem('student_session_id', sessionId);
    }

    // ---------- Live chat state ----------
    let isLiveChat = false;

    // ---------- WebSocket (lazy: open only after escalate) ----------
    let ws = null;
    function connectStudentSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) return;
      ws = new WebSocket(`${location.origin.replace('http', 'ws')}/ws/student/${sessionId}`);

      ws.onopen = () => console.log('Connected to live chat WebSocket');

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.type === 'message') {
          if (data.sender === 'admin') appendMessage('admin', data.message);
        }

        if (data.type === 'status' && data.status === 'live') {
          stopQueueTimer();
          liveStatus.classList.remove('hidden');
          appendMessage('system', 'An admin has joined the chat.');
        }

        if (data.type === 'queued_ping') {
          updateQueuePosition(data.queue_position);
        }
      };

      ws.onclose = () => {
        if (isLiveChat) {
          appendMessage('system', 'Live chat disconnected. You can try reconnecting.');
          leaveLiveChatUI();
        }
      };

      ws.onerror = (err) => console.error('WebSocket error:', err);
    }

    function updateQueuePosition(position) {
      const queueTimerEl = document.getElementById('queue-timer');
      if (position) {
        queueTimerEl.textContent = `Connecting you to an admin‚Ä¶ You are #${position} in the queue`;
        queueTimerEl.classList.remove('hidden');
      } else {
        queueTimerEl.textContent = 'Connecting you to an admin‚Ä¶';
      }
    }

    // ---------- Timer helpers ----------
    let _queueTimer = null, _queueEndAt = null;
    function startQueueTimer(seconds = 300) { // Default to 5 minutes
      console.log("Starting queue timer for", seconds, "seconds");
      _queueEndAt = Date.now() + seconds * 1000;
      renderTimer();
      queueTimerEl.classList.remove('hidden'); // Ensure the timer element is visible
      _queueTimer = setInterval(() => {
        console.log("Rendering timer...");
        renderTimer();
      }, 500);
    }
    function stopQueueTimer() {
      if (_queueTimer) clearInterval(_queueTimer);
      _queueTimer = null; _queueEndAt = null;
      queueTimerEl.classList.add('hidden');
    }
    mapCloseBtn.addEventListener('click', () => {
      stopVoiceNavigation();
      mapModal.classList.add('hidden');
      // Clear the map canvas so it reloads next time
      mapCanvas.innerHTML = '<div class="w-full h-full flex items-center justify-center text-gray-500">Loading map...</div>';
    });
    function renderTimer() {
      if (!_queueEndAt) {
        console.log("_queueEndAt is not set");
        return;
      }
      const remain = Math.max(0, Math.ceil((_queueEndAt - Date.now()) / 1000));
      const minutes = Math.floor(remain / 60);
      const seconds = remain % 60;
      console.log(`Time remaining: ${minutes}:${seconds}`);
      queueTimerEl.textContent = `Connecting you to an admin‚Ä¶ ${minutes}:${seconds.toString().padStart(2, '0')}`;
      queueTimerEl.classList.remove('hidden');
      if (remain <= 0) {
        stopQueueTimer();
        queueTimerEl.textContent = "Still waiting for an admin. Thank you for your patience.";
      }
    }
    function initMap() {
      console.log("Google Maps API loaded.");
    }

    // Utility to execute a callback once the Google Maps scripts have loaded.
    function withGoogleMaps(cb) {
      // If google.maps is already available, execute immediately.
      if (window.google && google.maps) {
        cb();
      } else {
        // Otherwise poll until the Maps library is ready.
        setTimeout(() => withGoogleMaps(cb), 50);
      }
    }



  
  async function showMapModal(destinationAddress, originAddress = null) {
  mapModal.classList.remove('hidden');
  mapCanvas.innerHTML =
    '<div class="w-full h-full flex items-center justify-center text-gray-500">Getting your location...</div>';

  // 1) Determine origin: if originAddress is provided, attempt to find that building. Otherwise, use the user's current geolocation.
  let userLocation;
  let isOriginProvided = !!originAddress;
  if (!isOriginProvided) {
    try {
      const position = await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
        });
      });
      userLocation = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
      };
    } catch (err) {
      console.error('Geolocation failed:', err);
      mapCanvas.innerHTML = `<div class="p-4 text-red-600">
        <strong>Error:</strong> Could not get your current location.<br>
        Please enable location permissions and try again.
      </div>`;
      return;
    }
  }

  mapCanvas.innerHTML =
    '<div class="w-full h-full flex items-center justify-center text-gray-500">Calculating route...</div>';

  try {
    // 2) Resolve destination and optional origin to campus buildings if possible
    const buildings = getCampusBuildings();
    const qDest = (destinationAddress || '').toLowerCase();
    let matchedBuilding = null;
    for (const b of buildings) {
      const name = (b.name || '').toLowerCase();
      if (name.includes(qDest) || qDest.includes(name)) {
        matchedBuilding = b;
        break;
      }
    }
    let destination = destinationAddress;
    let destinationLabel = destinationAddress;
    if (matchedBuilding) {
      destination = { lat: matchedBuilding.lat, lng: matchedBuilding.lng };
      destinationLabel = matchedBuilding.name;
    }

    // Resolve origin to a building if originAddress provided
    let origin = null;
    if (isOriginProvided) {
      const qOrig = (originAddress || '').toLowerCase();
      for (const b of buildings) {
        const name = (b.name || '').toLowerCase();
        if (name.includes(qOrig) || qOrig.includes(name)) {
          origin = { lat: b.lat, lng: b.lng };
          break;
        }
      }
      // If no building found, fallback to using user's current location (if available)
      if (!origin) {
        origin = userLocation;
        isOriginProvided = false;
      }
    } else {
      origin = userLocation;
    }

    // Choose a center for initial map display
    let destinationCenter;
    if (matchedBuilding) {
      destinationCenter = { lat: matchedBuilding.lat, lng: matchedBuilding.lng };
    } else {
      // fallback to origin if destination not recognized
      destinationCenter = origin;
    }

    // Build wrapper: map + overlay panel
    const mapId = `map_${Date.now()}`;
    const panelId = `panel_${Date.now()}`;

    mapCanvas.innerHTML = `
      <div class="relative w-full h-full">
        <div id="${mapId}" class="w-full h-full"></div>
        <div id="${panelId}"
             class="absolute bottom-3 left-1/2 -translate-x-1/2 bg-white/95 rounded-2xl shadow-lg flex items-start gap-3 px-4 py-3 max-w-md w-[90%] text-[11px] sm:text-xs border border-gray-200">
          <div class="flex-1">
            <div class="font-semibold text-gray-900 mb-1">${destinationLabel}</div>
            <div id="${panelId}-summary" class="text-gray-600 mb-1 text-[11px]"></div>
            <ul id="${panelId}-steps" class="space-y-0.5 text-gray-700 text-[11px]"></ul>
          </div>
          <button id="${panelId}-voice-btn"
                  class="ml-2 w-9 h-9 rounded-full flex items-center justify-center border border-gray-300 bg-white hover:bg-gray-50 shadow-sm"
                  title="Toggle voice navigation">
            <span id="${panelId}-voice-icon" class="text-lg">üîà</span>
          </button>
        </div>
      </div>
    `;

    const mapEl = document.getElementById(mapId);
    const panelSummary = document.getElementById(`${panelId}-summary`);
    const panelSteps = document.getElementById(`${panelId}-steps`);
    const voiceBtn = document.getElementById(`${panelId}-voice-btn`);
    const voiceIcon = document.getElementById(`${panelId}-voice-icon`);

    // 3) Initialize Map + Directions
    const directionsService = new google.maps.DirectionsService();
    const directionsRenderer = new google.maps.DirectionsRenderer({
      suppressMarkers: false,
    });

    const map = new google.maps.Map(mapEl, {
      center: destinationCenter,
      zoom: 17,
      mapTypeId: 'satellite',
      tilt: 45,
    });

    directionsRenderer.setMap(map);

    const request = {
      origin: origin,
      destination: destination,
      travelMode: google.maps.TravelMode.WALKING,
    };

    // 4) Get route + draw it
    const response = await directionsService.route(request);
    directionsRenderer.setDirections(response);

    const leg = response.routes[0]?.legs?.[0];
    if (!leg) {
      panelSummary.textContent = 'No walking route found.';
      return;
    }

    // Markers are already added by DirectionsRenderer; we just ensure center
    map.setCenter(leg.end_location);

    // Fill summary + a few steps for display
    panelSummary.textContent = `Distance: ${leg.distance.text} ¬∑ Est. time: ${leg.duration.text}`;

    panelSteps.innerHTML = '';
    const maxStepsToShow = 4;
    leg.steps.forEach((s, idx) => {
      if (idx >= maxStepsToShow) return;
      const li = document.createElement('li');
      const clean = s.instructions.replace(/<[^>]+>/g, '');
      li.textContent = `${idx === 0 ? 'A. ' : ''}${clean} (${s.distance.text})`;
      panelSteps.appendChild(li);
    });
    if (leg.steps.length > maxStepsToShow) {
      const li = document.createElement('li');
      li.textContent = '‚Ä¶';
      panelSteps.appendChild(li);
    }

    // 5) Voice navigation toggle using icon
    // For routes originating from the user's current location, enable step-by-step navigation; for building-to-building
    // routes, read out the full set of directions sequentially when the icon is pressed.
    let voiceActive = false;
    voiceBtn.onclick = () => {
      voiceActive = !voiceActive;
      if (voiceActive) {
        voiceIcon.textContent = 'üîä';
        if (!isOriginProvided) {
          startVoiceNavigation(leg, map);
        } else {
          // Speak the entire route instructions sequentially
          speakFullRoute(leg.steps);
        }
      } else {
        voiceIcon.textContent = 'üîà';
        stopVoiceNavigation();
      }
    };
  } catch (e) {
    console.error('Google Maps failed:', e);
    mapCanvas.innerHTML = `<div class="p-4 text-red-600">
      <strong>Error: Map failed to load.</strong><br>
      This is often because the 'Maps JavaScript API' or 'Directions API' is not enabled in the Google Cloud project.
    </div>`;
  }
}



    // ---------- UI helpers ----------
    function avatar(letter, color = 'from-tamuccBlue to-tamuccTeal') {
      return `<div class="w-10 h-10 bg-gradient-to-br ${color} rounded-full flex items-center justify-center text-white font-bold shadow-md flex-shrink-0">${letter}</div>`;
    }
    function escapeHTML(s) { return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }
    function renderMarkdown(md) {
      try {
        const html = marked.parse(md, { mangle: false, headerIds: false });
        return DOMPurify.sanitize(html);
      } catch {
        const div = document.createElement('div'); div.textContent = md || ""; return div.innerHTML;
      }
    }
    function enhanceLinks(el) {
      el.querySelectorAll('a').forEach(a => {
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.classList.add('text-tamuccTeal', 'underline', 'hover:text-tamuccLight', 'font-medium');
      });
    }

    function appendMessage(role, text, opts = {}) {
      const row = document.createElement('div');
      row.className = `flex mb-4 ${role === 'user' ? 'justify-end' : 'justify-start'}`;

      const time = new Date().toLocaleString();
      const chipsId = `fu_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

      if (role === 'bot') {
        const html = renderMarkdown(text);
        row.innerHTML = `
          ${avatar('S')}
          <div class="bg-white px-5 py-3 rounded-2xl rounded-tl-sm shadow-sm text-gray-800 max-w-[75%] border border-gray-100">
            <div class="prose prose-sm max-w-none">${html}</div>
            <div class="text-[10px] text-gray-400 text-right mt-2">${time}</div>
            <div id="${chipsId}" class="mt-3 flex flex-wrap gap-2"></div>
          </div>`;
        enhanceLinks(row);

        // per-message followups
        if (Array.isArray(opts.followups) && opts.followups.length) {
          const area = row.querySelector(`#${chipsId}`);
          opts.followups.forEach(sug => {
            const btn = document.createElement('button');
            btn.className = 'inline-flex items-center gap-2 px-4 py-2 rounded-lg border border-gray-200 bg-white hover:bg-gray-50 hover:border-tamuccTeal text-sm font-medium transition shadow-sm';
            btn.textContent = sug.label || 'Follow up';
            btn.onclick = async () => {
              area.innerHTML = '';
              area.classList.add('hidden');
              await onFollowupClick(sug);
            };
            area.appendChild(btn);
          });
        }
      } else if (role === 'user') {
        row.classList.add('justify-end');
        row.innerHTML = `
          <div class="bg-gradient-to-r from-tamuccBlue to-tamuccTeal text-white px-5 py-3 rounded-2xl rounded-tr-sm shadow-sm max-w-[75%]">
            <p>${escapeHTML(text)}</p>
            <div class="text-[10px] text-white/70 text-right mt-1">${time}</div>
          </div>`;
      } else if (role === 'admin') {
        row.innerHTML = `
          ${avatar('A', 'from-blue-500 to-blue-600')}
          <div class="bg-white px-5 py-3 rounded-2xl rounded-tl-sm shadow-sm text-gray-800 max-w-[75%] border border-blue-100">
            <span class="text-xs text-blue-600 font-semibold mr-2">üë®‚Äçüíº Admin</span>${escapeHTML(text)}
            <div class="text-[10px] text-gray-400 text-right mt-1">${time}</div>
          </div>`;
      } else if (role === 'system') {
        row.innerHTML = `
          <div class="mx-auto text-xs text-gray-600 bg-gray-100 border border-gray-200 px-4 py-2 rounded-full shadow-sm font-medium">
            ${escapeHTML(text)}
          </div>`;
      }

      chatWindow.appendChild(row);
      chatWindow.scrollTop = chatWindow.scrollHeight;

    }

    // ---------- Bot flow ----------
async function sendToBot(text) {
  const lower = text.toLowerCase();

  // 0) In "My Learning" mode, intercept requests asking about the student's own courses.
  // If the user asks "list my courses" or similar and we are in learning mode, we fetch the
  // student's registered courses directly from the server instead of calling the LLM.  This
  // prevents the assistant from responding with generic or random course lists.  We look
  // for phrases like "my courses", "list my courses", or questions about what courses
  // the user is enrolled in.  Only when the current chat mode is set to "learning"
  // (meaning the student is seeking information about their academic schedule) do we
  // handle the request here.
  if (chatMode === 'learning') {
    const courseKeywords = [
      'my courses',
      'list my courses',
      'what courses am i',
      'what courses i am',
      'courses i am',
      'courses i am registered',
      'courses i am enrolled',
      'courses i‚Äôm',
      "courses i'm"
    ];
    const asksForCourses = courseKeywords.some(k => lower.includes(k));

    if (asksForCourses) {
      try {
        // Fetch the current user to get their email.  If not logged in, bail out to LLM.
        const userRes = await fetch('/api/user');
        if (!userRes.ok) {
          throw new Error('Could not determine current user');
        }
        const userData = await userRes.json();
        if (!userData || !userData.email) {
          throw new Error('Missing user email');
        }
        const email = encodeURIComponent(userData.email);

        // Fetch the registered courses for this student.
        const coursesRes = await fetch(`/api/registered_courses/${email}`);
        if (!coursesRes.ok) {
          throw new Error('Failed to fetch registered courses');
        }
        const registered = await coursesRes.json();

        // Prepare a human-friendly response.  If the student is not registered for any
        // courses, let them know.  Otherwise, list each course with its title, CRN and
        // term if available.  We gracefully handle missing fields.
        let responseLines = [];
        if (!Array.isArray(registered) || registered.length === 0) {
          responseLines.push("It looks like you're not registered for any courses at the moment.");
        } else {
          responseLines.push('Here are your registered courses:');
          registered.forEach((reg, idx) => {
            const course = reg.course_details || {};
            const title = course.title || course.name || 'Unknown Course';
            const crn = course.crn || course._id || 'N/A';
            const term = course.term || reg.term || '';
            const details = [];
            if (crn !== 'N/A') details.push(`CRN: ${crn}`);
            if (term) details.push(`Term: ${term}`);
            const detailsStr = details.length ? ` (${details.join(', ')})` : '';
            responseLines.push(`${idx + 1}. ${title}${detailsStr}`);
          });
        }
        // Append the message from the bot with the compiled list.  No follow-ups
        // are provided in this special case.
        appendMessage('bot', responseLines.join('\n'));
        return;
      } catch (err) {
        console.error('Error fetching registered courses:', err);
        // If anything goes wrong, fall back to the usual LLM handling.
      }
    }
  }

  // 1) Explicit full campus map request
  if (
    lower.includes('campus map') ||
    lower.includes('show me the campus map') ||
    lower.includes('show campus map')
  ) {
    // We already appended the user message in onSend()
    showCampusMap(); // full campus map with all buildings
    return;
  }

  // 2) Location / "where is" style question that we can resolve locally
  const isLocationQuestion =
    lower.includes('where is') ||
    lower.includes('where\'s') ||
    lower.includes('location of') ||
    lower.includes('how do i get to') ||
    lower.includes('how to get to') ||
    lower.includes('directions to') ||
    lower.includes('navigate to');

  if (isLocationQuestion) {
    const loc = resolveCampusLocationFromText(text);
    if (loc) {
      answerWithLocationFromFrontend(loc);
      return; // don‚Äôt call backend at all
    }
  }

  // ------ existing admin / ticket / routing handling stays as it is ------
  const adminKeywords = ['talk to admin', 'speak to admin', 'connect me to admin', 'chat with admin', 'live chat', 'human support', 'talk to someone', 'speak to someone', 'real person', 'live support', 'need admin', 'want admin', 'get admin', 'contact admin'];
  const isAdminRequest = adminKeywords.some(keyword => lower.includes(keyword));

  if (isAdminRequest) {
    appendMessage('bot', 'üë®‚Äçüíº Connecting you with an admin for live support...');
    try {
      await escalateSession();
      connectStudentSocket();
      startQueueTimer(120);
      enterLiveChatUI();
      removeLiveChatCTA();
    } catch (err) {
      console.error('Error escalating to admin:', err);
      appendMessage('bot', '‚ùå Sorry, unable to connect to live support right now. Please try again in a moment.');
    }
    return;
  }

  // Ticket request detection and handling
  const ticketKeywords = [
    'raise ticket', 'raise a ticket', 'create ticket', 'create a ticket',
    'open ticket', 'open a ticket', 'support ticket', 'help ticket',
    'issue ticket', 'student issue', 'report issue', 'log complaint',
    'file complaint', 'having issue', 'facing issue', 'problem with'
  ];
  const isTicketRequest = ticketKeywords.some(keyword => lower.includes(keyword));
  if (isTicketRequest) {
    await handleTicketCreation(text);
    return;
  }

  // Routing between two named locations (already in your code)
  const routingKeywords = ['directions from', 'route from', 'how to get from', 'navigate from', 'walk from', 'directions between', 'route between', 'get to', 'from'];
  const isRoutingRequest = routingKeywords.some(keyword => lower.includes(keyword)) &&
    (lower.includes(' to ') || lower.includes(' and '));

  if (isRoutingRequest) {
    await handleRoutingRequest(text);
    return;
  }

  // NOTE: For all other questions we fall back to backend LLM as before
  typingIndicator.classList.remove('hidden');

  try {
    const formData = new FormData();
    formData.append('question', text);
    formData.append('mode', chatMode);

    const res = await fetch('/chat_question', { method: 'POST', body: formData });
    const data = await res.json();
    typingIndicator.classList.add('hidden');

    await streamMessage(data.answer, data.suggested_followups || [], data.suggest_live_chat || false);
  } catch (err) {
    typingIndicator.classList.add('hidden');
    console.error('Error:', err);
    appendMessage('bot', 'Sorry, something went wrong. Please try again later.');
  }
}

// ---------- voice based map ----------

// ---------- Voice navigation helpers ----------
let activeNavWatchId = null;
let activeNavSteps = [];
let activeNavStepIndex = 0;
let activeNavMarker = null;

function stopVoiceNavigation() {
  if (activeNavWatchId !== null) {
    navigator.geolocation.clearWatch(activeNavWatchId);
    activeNavWatchId = null;
  }
  if (window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
}

// Speak all navigation steps one by one with a short pause between each.
async function speakFullRoute(steps) {
  if (!Array.isArray(steps) || !steps.length) return;
  // Cancel any existing speech
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
  }
  for (let i = 0; i < steps.length; i++) {
    const step = steps[i];
    const clean = step.instructions.replace(/<[^>]+>/g, '');
    const text = `${clean}${step.distance && step.distance.text ? ' for ' + step.distance.text : ''}`;
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.rate = 1.0;
    window.speechSynthesis.speak(utterance);
    // Wait for current utterance to finish before proceeding to next step
    await new Promise(resolve => {
      utterance.onend = resolve;
    });
  }
}

function distanceMetersBetween(lat1, lng1, lat2, lng2) {
  const toRad = (x) => (x * Math.PI) / 180;
  const R = 6371000; // meters
  const dLat = toRad(lat2 - lat1);
  const dLng = toRad(lng2 - lng1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function speakStep(step, isFinal = false) {
  if (!('speechSynthesis' in window)) return;
  let text;
  if (isFinal) {
    text = 'You have arrived at your destination.';
  } else if (step) {
    const clean = step.instructions.replace(/<[^>]+>/g, '');
    const distText =
      step.distance && step.distance.text ? `, for ${step.distance.text}` : '';
    text = clean + distText;
  } else {
    return;
  }
  const u = new SpeechSynthesisUtterance(text);
  u.rate = 1.0;
  window.speechSynthesis.speak(u);
}

function startVoiceNavigation(leg, map) {
  stopVoiceNavigation();
  if (!leg || !Array.isArray(leg.steps) || !leg.steps.length) return;

  activeNavSteps = leg.steps;
  activeNavStepIndex = 0;

  // Announce the first step immediately
  activeNavSteps[0]._spoken = true;
  speakStep(activeNavSteps[0]);

  if (!navigator.geolocation) {
    console.warn('Geolocation not available for live navigation');
    return;
  }

  // Marker for current user position
  if (!activeNavMarker) {
    activeNavMarker = new google.maps.Marker({
      map,
      label: 'üë£',
      title: 'You',
      zIndex: 999,
    });
  }

  activeNavWatchId = navigator.geolocation.watchPosition(
    (pos) => {
      const lat = pos.coords.latitude;
      const lng = pos.coords.longitude;
      const userLatLng = new google.maps.LatLng(lat, lng);
      if (activeNavMarker) activeNavMarker.setPosition(userLatLng);

      const currentStep = activeNavSteps[activeNavStepIndex];
      if (!currentStep) return;

      const end = currentStep.end_location;
      const dist = distanceMetersBetween(
        userLatLng.lat(),
        userLatLng.lng(),
        end.lat(),
        end.lng()
      );

      const THRESHOLD_METERS = 23; // ~75 ft

      // When we are close to the end of this step, move to the next one
      if (dist <= THRESHOLD_METERS) {
        activeNavStepIndex += 1;
        const nextStep = activeNavSteps[activeNavStepIndex];
        if (nextStep) {
          speakStep(nextStep);
        } else {
          speakStep(null, true);
          stopVoiceNavigation();
        }
      }
    },
    (err) => {
      console.error('watchPosition error', err);
    },
    {
      enableHighAccuracy: true,
      maximumAge: 2000,
      timeout: 10000,
    }
  );
}

    // Function to simulate streaming effect
    async function streamMessage(fullText, followups, showLiveChatCTA) {
      const messageId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      const chipsId = `fu_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

      const row = document.createElement('div');
      row.className = 'flex mb-4 justify-start';
      row.id = messageId;

      const time = new Date().toLocaleString();
      row.innerHTML = `
        ${avatar('S')}
        <div class="bg-white px-5 py-3 rounded-2xl rounded-tl-sm shadow-sm text-gray-800 max-w-[75%] border border-gray-100">
          <div id="${messageId}-content" class="prose prose-sm max-w-none"></div>
          <div class="text-[10px] text-gray-400 text-right mt-2">${time}</div>
          <div id="${chipsId}" class="mt-3 flex flex-wrap gap-2"></div>
        </div>`;

      chatWindow.appendChild(row);
      chatWindow.scrollTop = chatWindow.scrollHeight;

      const contentDiv = document.getElementById(`${messageId}-content`);

      // Split text into words for streaming effect
      const words = fullText.split(' ');
      let currentText = '';

      for (let i = 0; i < words.length; i++) {
        currentText += (i > 0 ? ' ' : '') + words[i];
        contentDiv.innerHTML = renderMarkdown(currentText);
        enhanceLinks(row);
        chatWindow.scrollTop = chatWindow.scrollHeight;

        // Adjust delay based on word length for more natural feel
        const delay = words[i].length > 10 ? 30 : 20;
        await new Promise(resolve => setTimeout(resolve, delay));
      }

      // Ensure final content is fully rendered
      contentDiv.innerHTML = renderMarkdown(fullText);
      enhanceLinks(row);

      // üîπ If a "Show 3D Walking Map" follow-up exists, only show that one
      let filteredFollowups = Array.isArray(followups) ? [...followups] : [];
      const hasShowMap = filteredFollowups.some(
        (sug) => sug?.payload?.action === 'show_map'
      );
      if (hasShowMap) {
        filteredFollowups = filteredFollowups.filter(
          (sug) => sug?.payload?.action === 'show_map'
        );
      }

      // Add followup buttons after streaming is complete
      if (filteredFollowups.length > 0) {
        const chipsArea = document.getElementById(chipsId);
        filteredFollowups.forEach(sug => {
          const btn = document.createElement('button');
          btn.className = 'inline-flex items-center gap-2 px-4 py-2 rounded-lg border border-gray-200 bg-white hover:bg-gray-50 hover:border-tamuccTeal text-sm font-medium transition shadow-sm';
          btn.textContent = sug.label || 'Follow up';
          btn.onclick = async () => {
            chipsArea.innerHTML = '';
            chipsArea.classList.add('hidden');
            await onFollowupClick(sug);
          };
          chipsArea.appendChild(btn);
        });
      }

    }

    // ---------- Routing Integration ----------
    async function handleRoutingRequest(userMessage) {
      typingIndicator.classList.remove('hidden');

      try {
        const res = await fetch('/api/analyze_routing_request', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: userMessage })
        });

        const data = await res.json();
        typingIndicator.classList.add('hidden');

        if (data.found && data.origin && data.destination) {
          // Provide an instructional message before showing the map.
          appendMessage(
            'bot',
            `I'll help you get from **${data.origin.name}** to **${data.destination.name}**.\n\nI'm preparing the walking map with directions between these buildings.`,
          );
          // Delay opening the map for a brief moment so the message is visible
          setTimeout(() => {
            showMapModal(data.destination.name, data.origin.name);
          }, 3000);
        } else {
          // Show error message if we couldn't resolve both locations.
          appendMessage('bot', data.message || "I couldn't find both locations. Please try again with building names.");
        }
      } catch (err) {
        typingIndicator.classList.add('hidden');
        console.error('Error analyzing routing request:', err);
        appendMessage('bot', 'Sorry, I had trouble processing your routing request. Please try again.');
      }
    }



    // ---------- Map Integration ----------
    async function handleMapRequest(userMessage) {
      typingIndicator.classList.remove('hidden');

      try {
        const res = await fetch('/api/analyze_map_request', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: userMessage })
        });

        const data = await res.json();
        typingIndicator.classList.add('hidden');

        if (data.location) {
          showMap(data.location, data.description);
        } else {
          showCampusMap();
        }
      } catch (err) {
        typingIndicator.classList.add('hidden');
        console.error('Error analyzing map request:', err);
        showCampusMap(); // Fallback to general campus map
      }
    }

    function showMap(location, description) {
      const mapId = `map_${Date.now()}`;

      const row = document.createElement('div');
      row.className = 'flex mb-3 justify-start';
      row.innerHTML = `
        ${avatar('S')}
        <div class="bg-white px-4 py-2 rounded-2xl shadow text-gray-800 max-w-[85%] w-full">
          <p class="mb-2">${renderMarkdown(description || `Here's the location of **${location.name}**:`)}</p>
          <div id="${mapId}" style="height: 300px; width: 100%; border-radius: 12px; overflow: hidden; border: 2px solid #e5e7eb;"></div>
          <div class="text-[10px] opacity-60 text-right mt-1">${new Date().toLocaleString()}</div>
        </div>`;

      chatWindow.appendChild(row);
      chatWindow.scrollTop = chatWindow.scrollHeight;

      // Initialize map after DOM insertion
      setTimeout(() => initializeMap(mapId, location), 100);
    }

    function showCampusMap(highlightName = null) {
  const mapId = `map_${Date.now()}`;

  const row = document.createElement('div');
  row.className = 'flex mb-3 justify-start';
  row.innerHTML = `
    ${avatar('S')}
    <div class="bg-white px-4 py-2 rounded-2xl shadow text-gray-800 max-w-[85%] w-full">
      <p class="mb-2">üìç Here's the **TAMUCC Campus Map**. Hover or click on any building for more information:</p>
      <div id="${mapId}" style="height: 400px; width: 100%; border-radius: 12px; overflow: hidden; border: 2px solid #e5e7eb;"></div>
      <div class="text-[10px] opacity-60 text-right mt-1">${new Date().toLocaleString()}</div>
    </div>`;

  chatWindow.appendChild(row);
  chatWindow.scrollTop = chatWindow.scrollHeight;

  setTimeout(() => {
    withGoogleMaps(() => {
      const el = document.getElementById(mapId);
      if (!el) return;

      const buildings = getCampusBuildings();
      const center = buildings[0]
        ? { lat: buildings[0].lat, lng: buildings[0].lng }
        : { lat: 27.712, lng: -97.324 };

      const map = new google.maps.Map(el, {
        center,
        zoom: 17,
        mapTypeId: 'satellite',
        tilt: 45,
      });

      const highlightNorm = highlightName
        ? highlightName.toLowerCase()
        : null;

      buildings.forEach((b) => {
        const pos = { lat: b.lat, lng: b.lng };
        const isHighlight =
          highlightNorm &&
          (b.name || '').toLowerCase().includes(highlightNorm);

        const marker = new google.maps.Marker({
          position: pos,
          map,
          title: b.name,
          icon: isHighlight
            ? { path: google.maps.SymbolPath.CIRCLE, scale: 7, fillColor: '#16a34a', fillOpacity: 1, strokeColor: '#ffffff', strokeWeight: 2 }
            : undefined,
        });

        const info = new google.maps.InfoWindow({
          content: `
            <div style="font-size:12px;">
              <strong>${b.name}</strong><br/>
              ${b.description || ''}
            </div>`,
        });

        marker.addListener('click', () => info.open(map, marker));
        marker.addListener('mouseover', () => info.open(map, marker));
        marker.addListener('mouseout', () => info.close());
      });
    });
  }, 100);
}


    function initializeMap(mapId, location) {
      withGoogleMaps(() => {
        const el = document.getElementById(mapId);
        if (!el) return;

        const center = { lat: location.lat, lng: location.lng };

        const map = new google.maps.Map(el, {
          center,
          zoom: 18,
          mapTypeId: 'satellite',
          tilt: 45,
        });

        const marker = new google.maps.Marker({
          position: center,
          map,
          title: location.name || '',
        });

        let infoHtml = '<div style="min-width: 220px;">';
        infoHtml += `<h3 style="font-weight:bold;font-size:14px;margin-bottom:6px;color:#007A78;">${location.name || ''}</h3>`;
        if (location.address) {
          infoHtml += `<p style="font-size:12px;color:#666;margin-bottom:4px;">üìç ${location.address}</p>`;
        }
        if (location.description) {
          infoHtml += `<p style="font-size:12px;color:#333;margin-bottom:4px;">${location.description}</p>`;
        }
        if (location.hours) {
          infoHtml += `<p style="font-size:11px;margin-top:4px;color:#007A78;"><b>Hours:</b> ${location.hours}</p>`;
        }
        infoHtml += '</div>';

        const infoWindow = new google.maps.InfoWindow({ content: infoHtml });
        infoWindow.open(map, marker);
      });
    }


    function initializeCampusMap(mapId) {
      withGoogleMaps(() => {
        const el = document.getElementById(mapId);
        if (!el) return;

        // TAMUCC campus center
        const campusCenter = { lat: 27.7135, lng: -97.3265 };

        const map = new google.maps.Map(el, {
          center: campusCenter,
          zoom: 16,
          mapTypeId: 'roadmap',
        });

        const buildings = getCampusBuildings();

        buildings.forEach((building) => {
          const marker = new google.maps.Marker({
            position: { lat: building.lat, lng: building.lng },
            map,
            title: building.name,
          });

          let html = '<div style="min-width: 200px;">';
          html += `<h3 style="font-weight:bold;font-size:14px;margin-bottom:6px;color:#007A78;">${building.name}</h3>`;
          if (building.description) {
            html += `<p style="font-size:12px;color:#333;margin-bottom:4px;">${building.description}</p>`;
          }
          if (building.hours) {
            html += `<p style="font-size:11px;margin-top:4px;color:#555;"><b>Hours:</b> ${building.hours}</p>`;
          }
          if (building.link) {
            html += `<a href="${building.link}" target="_blank" style="display:inline-block;margin-top:6px;font-size:12px;color:#007A78;text-decoration:underline;">üìç More Info</a>`;
          }
          html += '</div>';

          const infoWindow = new google.maps.InfoWindow({ content: html });
          marker.addListener('click', () => infoWindow.open(map, marker));
        });
      });
    }


    function getCampusBuildings() {
      // TAMUCC Campus Buildings with accurate coordinates from Google Maps
      return [
        {
          name: "Mary and Jeff Bell Library",
          lat: 27.713788736691168,
          lng: -97.32474868648656,
          description: "Main campus library with study spaces and resources",
          hours: "Mon-Thu 7:30am-midnight, Fri 7:30am-6pm",
        },
        {
          name: "University Center (UC)",
          lat: 27.712071037382053,
          lng: -97.3257065414334,
          description: "Student life hub with dining, bookstore, and Island Grille",
          hours: "Mon-Fri 7am-10pm, Sat-Sun 10am-8pm",
        },
        {
          name: "Islander Dining",
          lat: 27.711621676963894,
          lng: -97.32258737277509,
          description: "Campus dining hall with various meal options",
          hours: "Mon-Fri 7am-8pm, Sat-Sun 10am-7pm",
        },
        {
          name: "Natural Resources Center (NRC)",
          lat: 27.715332468715157,
          lng: -97.32880933649331,
          description: "College of Science and Engineering, Computer Science",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "Corpus Christi Hall (CCH)",
          lat: 27.71516058584113,
          lng: -97.32370567166191,
          description: "Academic building with classrooms and faculty offices",
          hours: "Mon-Fri 7am-10pm",
        },
        {
          name: "Student Services Center",
          lat: 27.71374042156452,
          lng: -97.32390201020142,
          description: "Admissions, registrar, financial aid, and student services",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "Bay Hall",
          lat: 27.713613491472024,
          lng: -97.32348514338884,
          description: "Academic and administrative building",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "Center for the Sciences",
          lat: 27.712809298665885,
          lng: -97.32486990268086,
          description: "Science labs and research facilities",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "College of Education and Human Development",
          lat: 27.713186318706956,
          lng: -97.32428916719182,
          description: "Education programs and teacher preparation",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "Faculty Center",
          lat: 27.712820723536026,
          lng: -97.32358260567656,
          description: "Faculty offices and meeting spaces",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "Dugan Wellness Center",
          lat: 27.711601112024837,
          lng: -97.32413753070178,
          description: "Student health services and counseling",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "College of Business",
          lat: 27.714591440638948,
          lng: -97.32466461335527,
          description: "College of Business and entrepreneurship programs",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "Tidal Hall",
          lat: 27.715529412703646,
          lng: -97.32710819211944,
          description: "Student housing residence hall",
          hours: "24/7 for residents",
        },
        {
          name: "Harte Research Institute",
          lat: 27.713459500631362,
          lng: -97.32815759566772,
          description: "Gulf of Mexico research and marine science",
          hours: "Mon-Fri 8am-5pm",
        },
        {
          name: "University Counseling Center",
          lat: 27.712490577148014,
          lng: -97.32168122550681,
          description: "Mental health and counseling services for students",
          hours: "Mon-Fri 8am-5pm",
        }
      ];
    }

    // ---------- Ticket Creation Flow ----------
    let ticketData = {};
    let ticketStep = 0;

    async function handleTicketCreation(initialMessage) {
      ticketData = {
        description: initialMessage,
        category: '',
        priority: '',
        subject: ''
      };
      ticketStep = 0;

      appendMessage('bot', "I'll help you create a ticket for your issue. Let me gather some information...");

      // Use AI to extract initial information
      await analyzeTicketRequest(initialMessage);
    }

    async function analyzeTicketRequest(userMessage) {
      typingIndicator.classList.remove('hidden');

      try {
        const res = await fetch('/api/analyze_ticket', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: userMessage })
        });

        const data = await res.json();
        typingIndicator.classList.add('hidden');

        // Populate ticket data with AI analysis
        ticketData.subject = data.subject || '';
        ticketData.category = data.category || '';
        ticketData.priority = data.priority || 'Medium';
        ticketData.description = userMessage;

        // Show extracted information and ask for confirmation
        showTicketPreview();
      } catch (err) {
        typingIndicator.classList.add('hidden');
        console.error('Error analyzing ticket:', err);
        // Fallback to manual entry
        askForTicketSubject();
      }
    }

    function showTicketPreview() {
      const previewHTML = `
        **Here's the ticket I've prepared for you:**
        
        üìã **Subject**: ${ticketData.subject || 'Not specified'}
        üè∑Ô∏è **Category**: ${ticketData.category || 'General'}
        ‚ö° **Priority**: ${ticketData.priority || 'Medium'}
        üìù **Description**: ${ticketData.description}
        
        Is this information correct?
      `;

      const followups = [
        { label: '‚úÖ Yes, submit this ticket', payload: { type: 'action', action: 'submit_ticket' } },
        { label: '‚úèÔ∏è Edit subject', payload: { type: 'action', action: 'edit_subject' } },
        { label: 'üè∑Ô∏è Change category', payload: { type: 'action', action: 'edit_category' } },
        { label: '‚ö° Change priority', payload: { type: 'action', action: 'edit_priority' } },
        { label: '‚ùå Cancel', payload: { type: 'action', action: 'cancel_ticket' } }
      ];

      appendMessage('bot', previewHTML, { followups });
    }

    function askForTicketSubject() {
      appendMessage('bot', "What should be the subject of your ticket?");
      ticketStep = 1; // Waiting for subject
    }

    function askForTicketCategory() {
      const categoryOptions = [
        { label: 'üíª Technical Support', payload: { type: 'action', action: 'set_category', value: 'Technical Support' } },
        { label: 'üìö Academic', payload: { type: 'action', action: 'set_category', value: 'Academic' } },
        { label: 'üí∞ Financial', payload: { type: 'action', action: 'set_category', value: 'Financial' } },
        { label: 'üè† Housing', payload: { type: 'action', action: 'set_category', value: 'Housing' } },
        { label: 'üìù Registration', payload: { type: 'action', action: 'set_category', value: 'Registration' } },
        { label: 'üîß Other', payload: { type: 'action', action: 'set_category', value: 'Other' } }
      ];

      appendMessage('bot', "Please select a category for your ticket:", { followups: categoryOptions });
    }

    function askForTicketPriority() {
      const priorityOptions = [
        { label: 'üî¥ High', payload: { type: 'action', action: 'set_priority', value: 'High' } },
        { label: 'üü° Medium', payload: { type: 'action', action: 'set_priority', value: 'Medium' } },
        { label: 'üü¢ Low', payload: { type: 'action', action: 'set_priority', value: 'Low' } }
      ];

      appendMessage('bot', "What's the priority of this issue?", { followups: priorityOptions });
    }

    async function submitTicket() {
      typingIndicator.classList.remove('hidden');

      try {
        // Try to populate student info from /api/user before submitting
        try {
          const userRes = await fetch('/api/user');
          if (userRes.ok) {
            const userInfo = await userRes.json();
            if (userInfo.email) ticketData.student_email = userInfo.email;
            if (userInfo.full_name) {
              ticketData.student_name = userInfo.full_name;
            } else if (userInfo.email) {
              ticketData.student_name = userInfo.email;
            }
          }
        } catch (e) {
          // user not logged in or error retrieving info ‚Äì proceed anonymously
        }
        const res = await fetch('/api/tickets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(ticketData)
        });

        typingIndicator.classList.add('hidden');

        if (res.ok) {
          const result = await res.json();
          appendMessage('bot', `‚úÖ **Ticket created successfully!**\n\nYour ticket ID is: **${result.ticket_id}**\n\nYou can track its status in your student dashboard. An admin will review and assign it to the appropriate staff member soon.`);

          // Reset ticket data
          ticketData = {};
          ticketStep = 0;
        } else {
          appendMessage('bot', '‚ùå Sorry, there was an error creating your ticket. Please try again or contact support directly.');
        }
      } catch (err) {
        typingIndicator.classList.add('hidden');
        console.error('Error submitting ticket:', err);
        appendMessage('bot', '‚ùå Sorry, there was an error creating your ticket. Please try again or contact support directly.');
      }
    }

    // ---------- Escalation flow ----------
    async function escalateSession() {
      // Try to get student information if logged in
      let studentInfo = {
        student_name: null,
        student_email: null
      };

      try {
        const userRes = await fetch('/api/user');
        if (userRes.ok) {
          const user = await userRes.json();
          studentInfo.student_name = user.full_name || user.email || null;
          studentInfo.student_email = user.email || null;
        }
      } catch (err) {
        console.log('User not logged in, proceeding as guest');
      }

      const res = await fetch(`/api/chat/${sessionId}/escalate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(studentInfo)
      });
      if (!res.ok) throw new Error('Failed to escalate');
    }

    function enterLiveChatUI() {
      isLiveChat = true;
      endLiveBtn.classList.remove('hidden');
      appendMessage('system', 'Connecting with live support team‚Ä¶');
    }

    function removeLiveChatCTA() {
      document.querySelectorAll('#start-live-chat').forEach(btn => {
        const wrap = btn.parentElement;
        if (wrap) wrap.remove(); else btn.remove();
      });
    }

    function leaveLiveChatUI() {
      isLiveChat = false;
      endLiveBtn.classList.add('hidden');
      liveStatus.classList.add('hidden');
      stopQueueTimer();
      appendMessage('system', 'Live chat ended. You can continue with the assistant.');
    }

    async function onFollowupClick(sug) {
      if (sug?.payload?.type === 'faq' && sug.payload.query) {
        appendMessage('user', sug.payload.query);
        await sendToBot(sug.payload.query);
      } else if (sug?.payload?.type === 'action') {
        // Handle ticket creation actions
        if (sug.payload.action === 'submit_ticket') {
          await submitTicket();
        } else if (sug.payload.action === 'edit_subject') {
          askForTicketSubject();
        } else if (sug.payload.action === 'edit_category') {
          askForTicketCategory();
        } else if (sug.payload.action === 'edit_priority') {
          askForTicketPriority();
        } else if (sug.payload.action === 'set_category') {
          ticketData.category = sug.payload.value;
          appendMessage('user', sug.payload.value);
          showTicketPreview();
        } else if (sug.payload.action === 'set_priority') {
          ticketData.priority = sug.payload.value;
          appendMessage('user', sug.payload.value);
          showTicketPreview();
        } else if (sug.payload.action === 'cancel_ticket') {
          ticketData = {};
          ticketStep = 0;
          appendMessage('bot', 'Ticket creation cancelled. How else can I help you?');
        } else if (sug.payload.action === 'show_location_info' && sug.payload.destination) {
          // Fetch detailed information about the location and display it with an instructional preamble and follow‚Äëups
          try {
            const resp = await fetch('/api/get_location_info', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ location: sug.payload.destination }),
            });
            const info = await resp.json();
            if (info.found) {
              // Construct a message that introduces the destination and gives its details
              const preamble = `I'll help you reach **${info.name}**. Here's some basic info to get you started:\n\n`;
              let details = `**${info.name}**\n\n`;
              if (info.description) details += `${info.description}\n\n`;
              if (info.address) details += `üìç **Address:** ${info.address}\n`;
              if (info.hours) details += `üïí **Hours:** ${info.hours}\n`;
              if (info.category) details += `üìÇ **Category:** ${info.category}`;
              const fullMsg = preamble + details;
              // Offer follow‚Äëup options: directions with live walking and simple map view
              const followups = [
                {
                  label: 'üß≠ Directions (Live Walk)',
                  payload: { type: 'action', action: 'show_directions', destination: sug.payload.destination },
                },
                /* {
                  label: 'üó∫Ô∏è Show Map',
                  payload: { type: 'action', action: 'show_map', destination: sug.payload.destination },
                }, */
              ];
              appendMessage('bot', fullMsg, { followups });
            } else {
              appendMessage('bot', info.message || "I couldn't find details about that location.");
            }
          } catch (e) {
            console.error('Error fetching location info:', e);
            appendMessage('bot', 'Sorry, I had trouble fetching the location details.');
          }
        } else if (sug.payload.action === 'show_directions' && sug.payload.destination) {
          // Resolve the destination (and optional origin) into map coordinates
          try {
            const resp = await fetch('/api/get_directions', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ destination: sug.payload.destination }),
            });
            const data = await resp.json();
            if (data.found && data.destination) {
              // Provide an instructional message before opening the map
              appendMessage(
                'bot',
                `I'll help you reach **${data.destination.name}**.\n\nI'm preparing the live walking map and will open it shortly.`,
              );
              // Delay opening the map for a brief moment so the message is visible
              setTimeout(() => {
                showMapModal(sug.payload.destination);
              }, 3000);
            } else {
              appendMessage('bot', data.message || "I couldn't find that destination. Please try again.");
            }
          } catch (e) {
            console.error('Error fetching directions:', e);
            appendMessage('bot', 'Sorry, I had trouble looking up directions.');
          }
        } else if (sug.payload.action === 'show_map' && sug.payload.destination) {
          await showMapModal(sug.payload.destination);
        } else if (sug.payload.action === 'escalate') {
          try {
            await escalateSession();         // 1) mark queued
            connectStudentSocket();          // 2) open WS
            startQueueTimer(120);            // 3) show countdown
            enterLiveChatUI();               // 4) flip UI state
          } catch (e) {
            console.error(e);
            alert('Unable to start live chat right now. Please try again.');
          }
        } else if (sug.payload.action === 'show_campus_map') {
          // Optionally highlight the selected building on full campus map
          showCampusMap(sug.payload.destination || null);
        }

      }
    }

    // Try to match a building from user text using name + aliases
function resolveCampusLocationFromText(userText) {
  if (!userText) return null;
  const q = userText.toLowerCase();

  const buildings = getCampusBuildings().map(b => ({
    ...b,
    aliases: (b.aliases || []).map(a => a.toLowerCase()),
    _nameNorm: (b.name || "").toLowerCase()
  }));

  // Hard-coded common aliases (you can extend this list)
  const ALIAS_MAP = {
    uc: ['university center', 'university centre', 'uc building'],
    library: ['mary and jeff bell library', 'bell library'],
  };

  // First: if any explicit alias keyword appears, map to the right building
  for (const [aliasKey, targets] of Object.entries(ALIAS_MAP)) {
    if (q.includes(aliasKey)) {
      const targetLower = targets.map(t => t.toLowerCase());
      const match = buildings.find(
        b => targetLower.some(t => b._nameNorm.includes(t))
      );
      if (match) return match;
    }
  }

  // Second: try fuzzy match with building names / aliases
  let best = null;
  let bestScore = 0;

  for (const b of buildings) {
    const name = b._nameNorm;
    if (!name) continue;

    // Score based on overlaps
    let score = 0;
    if (q.includes(name) || name.includes(q)) score += 3;

    for (const alias of b.aliases) {
      if (q.includes(alias) || alias.includes(q)) score += 2;
    }

    // Partial words (e.g., "bell library" vs "library")
    const tokens = name.split(/\s+/);
    tokens.forEach(t => {
      if (t.length > 3 && q.includes(t)) score += 1;
    });

    if (score > bestScore) {
      bestScore = score;
      best = b;
    }
  }

  return bestScore >= 2 ? best : null;
}

// Render a nice answer for a known campus location
function answerWithLocationFromFrontend(location) {
  const lines = [];

  lines.push(`I'll help you get to **${location.name}**.`);
  lines.push('');
  lines.push('**About this location**');

  if (location.description) {
    lines.push(`- üìù ${location.description}`);
  }
  if (location.address) {
    lines.push(`- üìç **Address:** ${location.address}`);
  }
  if (location.hours) {
    lines.push(`- üïí **Hours:** ${location.hours}`);
  }
  if (location.category) {
    lines.push(`- üìÇ **Category:** ${location.category}`);
  }

  lines.push('');
  lines.push('You can open the live walking map with directions right from here.');

  const followups = [
    {
      label: 'üß≠ Directions (Live Walk)',
      payload: { type: 'action', action: 'show_directions', destination: location.name }
    },
    {
      label: 'üó∫Ô∏è Show campus map',
      payload: { type: 'action', action: 'show_campus_map', destination: location.name }
    }
  ];

  appendMessage('bot', lines.join('\n'), { followups });
}




    // ---------- Live chat send ----------
    function sendToLiveChat(text) {
      try {
        if (!ws || ws.readyState !== WebSocket.OPEN) throw new Error('WS not open');
        ws.send(JSON.stringify({ message: text }));
      } catch (e) {
        appendMessage('system', 'Could not send message. Please try again.');
      }
    }

    // ---------- Send button / input ----------
    async function onSend() {
      const text = chatInput.value.trim();
      if (!text) return;

      if (isLiveChat) {
        appendMessage('user', text);
        chatInput.value = '';
        sendToLiveChat(text);
        return;
      }

      // Bot mode - check if we're in ticket creation flow
      if (ticketStep === 1) {
        // User is providing subject
        ticketData.subject = text;
        appendMessage('user', text);
        chatInput.value = '';
        ticketStep = 0;
        showTicketPreview();
        return;
      }

      // Normal bot interaction
      appendMessage('user', text);
      chatInput.value = '';
      await sendToBot(text);
    }
    sendBtn.addEventListener('click', onSend);
    chatInput.addEventListener('keypress', (e) => (e.key === 'Enter') && onSend());

    // Escalate via legacy CTA button (if rendered)
    document.addEventListener('click', async (e) => {
      if (e.target && e.target.id === 'start-live-chat') {
        e.preventDefault();
        e.target.setAttribute('disabled', 'disabled');
        removeLiveChatCTA();
        try {
          await escalateSession();
          connectStudentSocket();
          startQueueTimer(120);
          enterLiveChatUI();
        } catch (err) {
          console.error(err);
          alert('Unable to start live chat right now. Please try again.');
        }
      }
    });

    // End live chat
    endLiveBtn.addEventListener('click', async () => {
      try { await fetch(`/api/chat/${sessionId}/end`, { method: 'POST' }); } catch { }
      // optionally close socket
      try { ws?.close(); } catch { }
      leaveLiveChatUI();
    });


    // Clear transcript
    clearChat.addEventListener('click', () => {
      chatWindow.innerHTML = `
        <div class="flex items-start space-x-3">
          <div class="w-10 h-10 bg-tamuccTeal rounded-full flex items-center justify-center text-white font-bold">S</div>
          <div class="bg-white px-4 py-2 rounded-2xl shadow text-gray-800 max-w-[70%]">
            üëã Hi! I‚Äôm <strong>SmartAssist</strong>. How can I help you today?
          </div>
        </div>`;
      typingIndicator.classList.add('hidden');
      stopQueueTimer();
      liveStatus.classList.add('hidden');
    });
  </script>
</body>

</html>